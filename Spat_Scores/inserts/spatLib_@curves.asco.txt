; SPATIAL LIBRARY FOR ...of Silence, version 2014
; Last update: 01/01/2015
/*NOTES:
	This library uses an Antescofo map called $initlevels that contains destinations (as key strings)
	and their coordinates (as value tables).
	It should be defined by user.
	
	Definition example
	$initlevels := map {
	("FadeOut", [0., 0., 0., 0., 0.]),
	("Left", [0., 1., 0., 0., 0.])
	} */




; Initialize and (re)construct $source structure
@proc_def ::InitSources($NumberOfSources, $NumberOfSpeakers)
{
	abort ::source
	;; (re)define source structure
	$source := [ [0.0 | ($NumberOfSpeakers)] | ($NumberOfSources)]	
    print_antescofo The source matrix has dimension @dim($source) with @size($source) coordinates and @size($source[1]) sources 
    ;; (re)instantiate source processes
    $t := tab [$x | $x in $NumberOfSources]
    forall $x in $t
    {
    	::source($x)
    }
}

; define $initlevels here in case it is undefined. User definition SHOULD come next (after @include)
if (@is_undef($initlevels))
{
	print_antescofo SPAT LIB: initlevels was set to empty
	$initlevels := map { }
}

; define $source here in case it is undefined. User definition SHOULD come next (after @include)
if (@is_undef($source))
{
	; defines the matrix containing # of points/speakers (5) and number of sources (10)
	$source := [ [0.0 | (2)] | (10)]		; last element is at $source[10,5]
}

; CLASS SOURCE
@proc_def ::source($id)
{
	@local  $last_action
    $last_action := 0    

	; GENERAL PROCESSES    
	whenever($Ticket[0] == $id)
	{
		;print Source ($id) Called with destination ($Ticket[1])
		abort $last_action
		$last_action := ::FlyTo($Ticket[0], $Ticket[1], $Ticket[2])
	}
	
	whenever ($abort == $id)
	{
		abort $last_action
		$last_action := 0
	}
	; Generic mouvement process
	whenever($Move[0] == $id)
	{
		abort $last_action
		$last_action := ::Move($Move[0], $Move[1], $Move[2])
	}
}


/*	Generic movement method.
	Input arguments:
		$sourcenum:	Integer identifier for source number
		$destination:	Symbol identifying the destination. MUST BE a member of initlevels MAP
		$dur:		Duration of interpolation */

@proc_def ::FlyTo($sourcenum, $destination, $dur)
{
  curve FlyingEngine   @Grain := 0.05s, 
		@Action := 
		{
			let $source[$sourcenum] := ($x)
			@command("spat"+$sourcenum) ($x) 
		}
		{
			$x
			{
		{ ($source[$sourcenum]) }	@type "sine_in_out"
			$dur   	{ ($initlevels($destination)) } @type "sine_in_out"
			}
		}
}

/////////////
/*@proc_def ::FlyTo($sourcenum, $destination, $dur)
{
  ::gauss()
}*/

///////////// Modular movement process
; define spatialization break-points
;$h1 := ($initlevels("Front"))
;$h2 := ($initlevels("Left"))
;$h3 := ($initlevels("Rear"))
;$h4 := ($initlevels("Right"))
;$h5 := ($initlevels("Vert"))
$SpeakerArray := [ ($initlevels("Front")), ($initlevels("Left")), ($initlevels("Rear")), ($initlevels("Right")), ($initlevels("Vert"))]
$typ := ["SINE_IN_OUT" | (5)]


; Arguments are:
;			$sourcenum  : 	Spatialisation source number / integer
;			$source_tab :	movement table / table, as in [1, 2, 3] -- NOTE: Use colons to separate table elements!
;			$dur		:	global duration / float

@macro_def Move($source,$sourcetab, $dur) { $Move := [$source,$sourcetab, $dur] }
@proc_def ::Move($sourcenum, $source_tab, $dur)
{
	@local $interpol				; interpolation map to be constructed from $source_tab
	@local $abstract_duration		; abstract duration (scrub) of the interpolation map
	$abstract_duration := 1.0

	; construct the first element, and then go for others.. 
	;	we have to this since we don't really have types. So for using PUSH_BACK we need to construct atleast the first element!
	;	The interpolation map starts on the last position, and interpolates to the first position in $source_tab
	
	$interpol := NIM { 0 ($source[$sourcenum]), 1.0 ($SpeakerArray[$source_tab[0] - 1]) "SINE_IN_OUT" }

	; now we iterate on the rest of the table (if any) and push elements incrementally
	$index_list := [ $i | $i in 1 .. @size($source_tab) ]

	forall $i in $index_list
	{
		;print constructing nim "for" ($source_tab[$i])
		$abstract_duration := $abstract_duration + 1.0
		; push back the last element into the interpolation map
		$interpol := @push_back($interpol, 1.0, $SpeakerArray[$source_tab[$i] - 1], "SINE_IN_OUT")
	}

	; Now drive the interpolation map using a curve and the given duration.
	; The principle is the following: The NIM is constructed on an x-axis that corresponds to a total $abstract_time
	; The curve is like a header that reads this interpolation map in the given duration.


	curve nimclock @grain:=0.05s,
		@action :=
		{
			let $source[$sourcenum] := $interpol($x)
			@command("spat"+$sourcenum) ( $interpol($x) )
		}
		{
			$x
			{
				{0.0}
				$dur {$abstract_duration}
			}
		}

}

//////////////////////////////////////////////////////////

; SPACE VOCABULARY

; SINGLE LOUDSPEAKERS
; Front [1], Left [2], Rear [3], Right [4], Vert [5]
; NB: -Lsp = phase opposition (ex. -1)

; DOUBLE LOUDSPEAKERS
; DIPOLES [1] = IN PHASE
; FrontalDipole[1] [1-3] / LateralDipole[1] [2-4]
; HORIZONTAL
; FrontLeftCorner[1] [1-2] / RearLeftCorner[1] [2-3] / RearRightCorner[1] [3-4] / FrontRightCorner[1] [4-1]
; VERTICAL
; FrontVertCorner[1] [5-1] / LeftVertCorner[1] [5-2] / RearVertCorner[1] [5-3] / RightVertCorner[1] [5-3] 
 
; TRIPLE LOUDSPEAKERS
; FrontTriple[1] [1-2 3], LeftTriple[1] [1-2 3], RearTriple[1] [2-3 4], RightTriple[1] [3-4 1]

; QUADRUPLE LOUDSPEAKERS
; AllHorizontal [1-2 3-4]
; AllDipoles [1 2-3-4]
; AllHorizontalinPhase [1 2 3 4]

; AllVertical
; AllinPhase
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


;_________________________________________________________________________________________
; General SPACE Macro to assign movements to sources.
; Arguments:
;	1st argument: source number (integer)
;	2nd argument:	movement type (string) --> must be in the $initlevels map. Must be wrapped in quotations
;	3rd argument: duration (float, or time in second or milli-second: ex. 3.0 or 3.0s or 3.0ms)
@macro_def Space($snum, $stype, $sdur) {	$Ticket := [$snum, $stype, $sdur]	}

;FadeOut
@macro_def FadeOut($sourcenum, $dur) { $Ticket := [$sourcenum,"FadeOut", $dur] }

;_________________________________________________________________________________________
/**** Random Granular Spatial Movement Process
* Arguments:
*	arg1 $snum:				int -	source number
*	arg2 $configs: table of string configurations from $initlevels. ex: [ "Front", "Rear", "Right"]
*	arg3 $grainrange_min:	float - minimum grain time
*	arg4 $grainrange_max: 	float - maximum grain time
*	arg5 $stay_percent:		float (0.to 1.) - percentage of staying on selected configuration
** IMPORTANT: For now, we give time values in relative. Tempo is fixed inside as 60 BPM.
**				This means that $grainrange_min 0.05 is 50ms
****/
@proc_def ::RandomSpace($snum, $configs, $grainrange_min, $grainrange_max, $stay_percent)
{
	;;; Generate first randoms:
	@local $grainsize, $randomconfig
	$grainsize := @random() * ($grainrange_max - $grainrange_min) + $grainrange_min
	print DEBUG: Initial grain set to ($grainsize)
	Loop L	$grainsize
	{
		; Generate a random configuration.
		$randomconfig := ($configs[@rand_int(@size($configs))])
		; Make the move, in duration that is (1.0 - $stay_percent). 
		$Ticket := [$snum, $randomconfig, ($grainsize*(1.0-$stay_percent))]
		
		print "DEBUG: random space with grain" ($grainsize) "on" ($randomconfig)
		; Generate a new period just before this loop is finishes! Looks like a harakiri!
		$grainsize	$grainsize := @random() * ($grainrange_max - $grainrange_min) + $grainrange_min
	}
}


;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


;one og my inserts




